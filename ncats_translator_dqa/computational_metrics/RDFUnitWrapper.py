"""Wrapper for calling RDFUnit
"""
import os
import sys
import subprocess
import shutil
from ncats_translator_dqa import config


class RDFUnitWrapper:
    __rdfunit_output_extension = '.shaclFullTestCaseResult.ttl'

    def __init__(self, path_rdfunit=config.path_rdfunit, verbose=config.verbose):
        """Constructor

        :param path_rdfunit: Absolute path to the RDFUnit base directory (one folder above bin)
        :param verbose: True if you want to print status messages
        """
        self.path_rdfunit = path_rdfunit
        self.__bin_rdfunit = os.path.join(self.path_rdfunit, 'bin/rdfunit')
        self.__bin_dqvreport = os.path.join(self.path_rdfunit, 'bin/dqv-report')
        self.verbose = verbose

    def rdfunit(self, dataset_uri, sparql_endpoint=None, sparql_graph=None, schema=''):
        """Calls rdfunit on the given dataset

        :param dataset_uri: Dataset URI (i.e., the -d parameter to rdfunit)
        :param sparql_endpoint: SPARQL endpoint (i.e., the -e parameter to rdfunit)
        :param sparql_graph: SPARQL graph (i.e., the -g parameter to rdfunit)
        :param schema: URI to schema to perform validation against or defined schema prefix. Leave empty for automatic
         detection of ontologies by rdfunit (String) [optional]
        :return: Path of the output file generated by rdfunit
        """
        if self.verbose:
            print('Running rdfunit on ' + dataset_uri)

        # Run rdfunit
        process_cmd_list = [self.__bin_rdfunit, '-d', dataset_uri, '-r', 'shacl', '-o', 'html,turtle']
        if sparql_endpoint is not None:
            process_cmd_list = process_cmd_list + ['-e', sparql_endpoint]
            if sparql_graph is not None:
                process_cmd_list = process_cmd_list + ['-g', sparql_graph]
        if len(schema) > 0:
            process_cmd_list = process_cmd_list + ['-s', schema]
        cp = subprocess.run(process_cmd_list, stdout=subprocess.PIPE, stderr=subprocess.PIPE, encoding='UTF-8',
                            cwd=self.path_rdfunit)

        # Check the return code for errors
        if cp.returncode != 0:
            sys.stderr.write('There was an error running rdfunit\n')
            sys.stderr.write(str(cp.args))
            sys.stderr.write(cp.stderr)
            sys.stderr.write(cp.stdout)
            raise Exception('rdfunit error')

        # Build the expected filename of the output file written by rdfunit
        filename_dataset_sanitized = dataset_uri.replace(os.sep, '_')
        file_rdf_output = os.path.join(self.path_rdfunit, 'data', 'results',
                                       filename_dataset_sanitized + RDFUnitWrapper.__rdfunit_output_extension)

        # Check that the output file was created
        if not os.path.exists(file_rdf_output):
            # Try to extract the output file name from the output log (rdfunit writes output to stderr)
            output_line = cp.stderr.split('\n')[-2]
            file_rdf_output = output_line.split(' ')[-1]
            file_rdf_output = file_rdf_output.replace('*', 'ttl')
            file_rdf_output = os.path.join(self.path_rdfunit, file_rdf_output)

            # Check if this output file exists
            if not os.path.exists(file_rdf_output):
                sys.stderr.write('Could not find the output RDF file from rdfunit\n')
                raise FileNotFoundError(file_rdf_output)

        # Move the output files from the <RDFUnit>/data/results to the configured output directory
        filename_dataset = os.path.split(dataset_uri)[1]
        filename_dataset = os.path.splitext(filename_dataset)[0]
        file_rdfunit_new = os.path.join(config.path_output, filename_dataset + '_computational_metrics.ttl')
        shutil.move(file_rdf_output, file_rdfunit_new)
        #os.rename(file_rdf_output, file_rdfunit_new)

        # Move the html file also
        filename_rdf_output = os.path.split(file_rdf_output)[1]
        filename_rdf_output = os.path.splitext(filename_rdf_output)[0]
        file_html_old = os.path.join(config.path_rdfunit, 'data', 'results', filename_rdf_output + '.html')
        file_html_new = os.path.join(config.path_output, filename_dataset + '_computational_metrics.html')
        shutil.move(file_html_old, file_html_new)
        #os.rename(file_html_old, file_html_new)

        if self.verbose:
            print('rdfunit finished. output file: ' + file_rdfunit_new)

        # Return the path to the rdfunit output file
        return file_rdfunit_new

    def dqv_report(self, file_rdf_output):
        """Calls dqv-report on the given file

        :param file_rdf_output: The output file from rdfunit to use as input to dqv-report (i.e., the -i parameter)
        :return: Path to the output file generated by dqv-report
        """
        if self.verbose:
            print('Running dqv-report on ' + file_rdf_output)

        # Generate an output filename for the dqv report
        filename_dqv_report = os.path.split(file_rdf_output)[1] + '.dqv_report.ttl'
        file_dqv_report_rel = os.path.join('data/results', filename_dqv_report)

        # Run dqv-report
        cp = subprocess.run([self.__bin_dqvreport, '-i', file_rdf_output, '-o', file_dqv_report_rel],
                            stdout=subprocess.PIPE, stderr=subprocess.PIPE, encoding='UTF-8', cwd=self.path_rdfunit)

        # Check the return code for errors
        if cp.returncode != 0:
            sys.stderr.write('There was an error running dqv-report\n')
            sys.stderr.write(str(cp.args) + '\n')
            sys.stderr.write(cp.stderr)
            sys.stderr.write(cp.stdout)
            raise Exception('dqv-report error')

        # Check that the dqv report file was created
        file_dqv_report = os.path.join(self.path_rdfunit, file_dqv_report_rel)
        if not os.path.exists(file_dqv_report):
            sys.stderr.write('Could not find the dqv-report generated file: ' + file_dqv_report + '\n')
            raise FileNotFoundError(file_dqv_report)

        # Move the output file from the <RDFUnit>/data/results to the configured output directory
        file_dqv_new = os.path.join(config.path_output, filename_dqv_report)
        os.rename(file_dqv_report, file_dqv_new)

        if self.verbose:
            print('dqv-report finished. output file: ' + file_dqv_new)

        # Return the path to the dqv report file
        return file_dqv_new
